from contextlib import contextmanager

from django.http import fix_location_header
from django.test.client import RequestFactory
from django.utils.translation import get_language

import test_utils
from funfactory.urlresolvers import get_url_prefix, Prefixer, set_url_prefix
from nose.tools import eq_
from tower import activate

from flicks.base.util import redirect


@contextmanager
def lang_activate(locale):
    """
    Context manager that temporarily activates a locale.

    This is slightly different from use_lang, as it also sets the global
    prefixer used by reverse to determine the locale in urls. We don't use that
    in non-test code because it creates a test request using Django test code.

    This means that use_lang does not affect reverse. We get around that with a
    hack of using the lang GET argument when necessary, but this really should
    be fixed someday.
    """
    if not locale:
        yield
    else:
        old_prefix = get_url_prefix()
        old_locale = get_language()
        rf = test_utils.RequestFactory()
        set_url_prefix(Prefixer(rf.get('/%s/' % (locale,))))
        activate(locale)
        yield
        set_url_prefix(old_prefix)
        activate(old_locale)


def redirects_(response, to, request=None, permanent=False, locale=None):
    """
    Asserts that the given response redirects to the location specified by to.

    :param response:
        Response that should be redirecting.
    :param to:
        Path that the response should redirect to. Accepts a view name or url.
    :param request:
        Request that generated the response being tested. Required in cases
        where the redirect was generated by a request, which affects the value
        of the Location header.

        If none is given, a sample request will be generated and used. This
        should handle the common case of testing a response from the test
        client.
    :param permanent:
        If true, check for a 301 redirect instead of a 302 redirect. Defaults to
        False.
    """
    # We're going to cheat and piggyback on redirect's lovely handling of the
    # `to` argument.
    with lang_activate(locale):
        expected = redirect(to, permanent=permanent)

    # Fix location header for both requests so we can compare.
    if not request:
        request = RequestFactory().get(expected['Location'])
    expected = fix_location_header(request, expected)
    response = fix_location_header(request, response)

    eq_(expected.status_code, response.status_code)
    eq_(expected['Location'], response['Location'])


class CONTAINS(object):
    """
    Helper object that checks for equalness by checking if the compared object
    contains elements passed in the constructor.
    """
    def __init__(self, *args):
        self.values = args

    def __eq__(self, other):
        return all(value in other for value in self.values)

    def __ne__(self, other):
        return any(value not in other for value in self.values)

    def __repr__(self):
        return '<CONTAINS {0}>'.format(self.values)
