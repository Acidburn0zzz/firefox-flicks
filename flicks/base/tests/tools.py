from django.http import fix_location_header
from django.shortcuts import redirect
from django.test.client import RequestFactory

from nose.tools import eq_


def redirects_(response, to, request=None, permanent=False):
    """
    Asserts that the given response redirects to the location specified by to.

    :param response:
        Response that should be redirecting.
    :param to:
        Path that the response should redirect to. Accepts a model, view name,
        or url (anything that django.shortcuts.redirect accepts).
    :param request:
        Request that generated the response being tested. Required in cases
        where the redirect was generated by a request, which affects the value
        of the Location header.

        If none is given, a sample request will be generated and used. This
        should handle the common case of testing a response from the test
        client.
    :param permanent:
        If true, check for a 301 redirect instead of a 302 redirect. Defaults to
        False.
    """
    # We're going to cheat and piggyback on redirect's lovely handling of the
    # `to` argument.
    expected = redirect(to, permanent=permanent)

    # Fix location header for both requests so we can compare.
    if not request:
        request = RequestFactory().get(expected['Location'])
    expected = fix_location_header(request, expected)
    response = fix_location_header(request, response)

    eq_(expected.status_code, response.status_code)
    eq_(expected['Location'], response['Location'])


class CONTAINS(object):
    """
    Helper object that checks for equalness by checking if the compared object
    contains elements passed in the constructor.
    """
    def __init__(self, *args):
        self.values = args

    def __eq__(self, other):
        return all(value in other for value in self.values)

    def __ne__(self, other):
        return any(value not in other for value in self.values)

    def __repr__(self):
        return '<CONTAINS {0}>'.format(self.values)
